6.4s to do 10 bits on RPi with compiler optimisations enabled

rough complexity factor of 4 for each additional bit

================================================================================

Prediction for time completion of various bit sizes based on this measurement:

bits time (s)  time context
10 - 0000006.4
11 - 0000025.6
12 - 0000102.4
13 - 0000409.6 (6.82 mins)
14 - 0001638.4 (27.3 mins)
15 - 0006553.6 (109 mins)
16 - 0026214.4 (7.28 hours)
17 - 0104857.6 (29.1 hours)
18 - 0419430.4 (4.85 days) <--- STOP HERE!
19 - 1677721.6 (19.4 days)
20 - 6710886.4 (2.58 months)

================================================================================

Time Estimate:

Sum of all times up to and including 18 bits = 559238.4 (6.47 days)

Generalised, for calculating how long it would take to calculate 1 bit more including this:

6.4 + (4 * 6.4)

for 2 bits more:

6.4 + (4 * 6.4) + (4 * 4 * 6.4)

for 3 bits more:

6.4 + (4 * 6.4) + (4 * 4 * 4 * 6.4)

Generalised further:

where t is the time taken to compute a reference complexity r, and complexity c is the desired complexity to calculate time up to:

total = 0.0
for p in range 0..(c - r):
    total += t * 4 ^ p

TODO: Improve time estimates by deriving a more exact complexity factor that is variable between runs, taking into account a more precise model of the relative complexity of solving with regard to problem size (number of bits is n, a program complexity proportional to n can be derived). We can then divide the wall-clock execution time of each run by the respective value derived from proportionality to n (to get a pretty good measurement of how long the smallest chunk of the algo takes to run) and multiply this by the value derived from n-proportionality for the next-largest problem size, hence getting the most accurate time estimate possible.

**INVALID ORIGINAL ESTIMATE:**

Accounting for accuracy and accumulation, estimate that a 7-day window of
uninterrupted computation is needed to explore problem space up to 18 bits.
