<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>sxbp: sxbp/sxbp.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="libsxbp.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">sxbp
   &#160;<span id="projectnumber">v0.54.0</span>
   </div>
   <div id="projectbrief">Experimental generation of 2D spiralling lines based on input binary data.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('sxbp_8h.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">sxbp.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<h3 class="version">(v0.27.0)</h3>
<p>This header file provides the entire public API of sxbp.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;stdbool.h&gt;</code><br />
<code>#include &lt;stddef.h&gt;</code><br />
<code>#include &lt;stdint.h&gt;</code><br />
<code>#include &lt;stdio.h&gt;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for sxbp.h:</div>
<div class="dyncontent">
<div class="center"><img src="sxbp_8h__incl.png" border="0" usemap="#sxbp_2sxbp_8h" alt=""/></div>
<map name="sxbp_2sxbp_8h" id="sxbp_2sxbp_8h">
</map>
</div>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxbp__version__t.html">sxbp_version_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to represent a version of sxbp.  <a href="structsxbp__version__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxbp__buffer__t.html">sxbp_buffer_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple buffer type for storing arrays of bytes.  <a href="structsxbp__buffer__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxbp__line__t.html">sxbp_line_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents one line segment in the spiral structure.  <a href="structsxbp__line__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxbp__figure__t.html">sxbp_figure_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A structure representing an SXBP 'spiral' figure.  <a href="structsxbp__figure__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxbp__begin__figure__options__t.html">sxbp_begin_figure_options_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A structure used for providing options to <code><a class="el" href="structsxbp__figure__t.html#a8c7e90107e0cdb6426a834cb9fe6191f" title="Converts the given binary data into an early-draft SXBP figure. ">sxbp_begin_figure()</a></code>  <a href="structsxbp__begin__figure__options__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxbp__refine__figure__options__t.html">sxbp_refine_figure_options_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A structure used for providing options to <code><a class="el" href="structsxbp__figure__t.html#a7fed45c99b756b15baf9bd6f6eef55a7" title="Refines the line lengths of the given SXBP figure. ">sxbp_refine_figure()</a></code>  <a href="structsxbp__refine__figure__options__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxbp__render__options__t.html">sxbp_render_options_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A structure used for providing options to <code><a class="el" href="structsxbp__figure__t.html#ad7a36f65cec14ede4ba02eb7cee1bdb5" title="Renders an image of the given figure, using the given render callback. ">sxbp_render_figure()</a></code>  <a href="structsxbp__render__options__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxbp__bitmap__t.html">sxbp_bitmap_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to represent a basic 1-bit, pure black/white bitmap image.  <a href="structsxbp__bitmap__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ad10ba5c361be12daef8ed43bd55eb753"><td class="memItemLeft" align="right" valign="top">typedef uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sxbp_8h.html#ad10ba5c361be12daef8ed43bd55eb753">sxbp_length_t</a></td></tr>
<tr class="memdesc:ad10ba5c361be12daef8ed43bd55eb753"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type for representing the length of a line segment of a spiral.  <a href="#ad10ba5c361be12daef8ed43bd55eb753">More...</a><br /></td></tr>
<tr class="separator:ad10ba5c361be12daef8ed43bd55eb753"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64e2ae7e91a4c4f52af7487f7a32d0d2"><td class="memItemLeft" align="right" valign="top">typedef uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sxbp_8h.html#a64e2ae7e91a4c4f52af7487f7a32d0d2">sxbp_figure_size_t</a></td></tr>
<tr class="memdesc:a64e2ae7e91a4c4f52af7487f7a32d0d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type for representing the size of an SXBP figure.  <a href="#a64e2ae7e91a4c4f52af7487f7a32d0d2">More...</a><br /></td></tr>
<tr class="separator:a64e2ae7e91a4c4f52af7487f7a32d0d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1645a3341032b7107ed60f9be72b6f70"><td class="memItemLeft" align="right" valign="top">typedef uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sxbp_8h.html#a1645a3341032b7107ed60f9be72b6f70">sxbp_figure_dimension_t</a></td></tr>
<tr class="memdesc:a1645a3341032b7107ed60f9be72b6f70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type for representing the width or height of a rendered SXBP figure.  <a href="#a1645a3341032b7107ed60f9be72b6f70">More...</a><br /></td></tr>
<tr class="separator:a1645a3341032b7107ed60f9be72b6f70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6190ffd788551f95618ccb01bf753723"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="sxbp_8h.html#adba112e91a18b8f807ce639167da1150">sxbp_result_t</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sxbp_8h.html#a6190ffd788551f95618ccb01bf753723">sxbp_figure_renderer_t</a>) (const <a class="el" href="structsxbp__figure__t.html">sxbp_figure_t</a> *const figure, <a class="el" href="structsxbp__buffer__t.html">sxbp_buffer_t</a> *const buffer, const <a class="el" href="structsxbp__render__options__t.html">sxbp_render_options_t</a> *const render_options, const void *render_callback_options)</td></tr>
<tr class="memdesc:a6190ffd788551f95618ccb01bf753723"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience typedef for a callback function that renders a figure.  <a href="#a6190ffd788551f95618ccb01bf753723">More...</a><br /></td></tr>
<tr class="separator:a6190ffd788551f95618ccb01bf753723"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a432c1738056ae8f9c53aa2dccd2a6a3a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sxbp_8h.html#a432c1738056ae8f9c53aa2dccd2a6a3a">sxbp_direction_t</a> { <a class="el" href="sxbp_8h.html#a432c1738056ae8f9c53aa2dccd2a6a3aa85f442e9a2fd78d9d8ad911b4e85a0ac">SXBP_UP</a> = 0u, 
<a class="el" href="sxbp_8h.html#a432c1738056ae8f9c53aa2dccd2a6a3aa31f3f25c44e418c6a6784cfb22d3b3d2">SXBP_RIGHT</a> = 1u, 
<a class="el" href="sxbp_8h.html#a432c1738056ae8f9c53aa2dccd2a6a3aa71675a500a7a7433b603bbe96c258903">SXBP_DOWN</a> = 2u, 
<a class="el" href="sxbp_8h.html#a432c1738056ae8f9c53aa2dccd2a6a3aa74ae9ed8847a8a29bc952b0f9e576e0c">SXBP_LEFT</a> = 3u
 }</td></tr>
<tr class="memdesc:a432c1738056ae8f9c53aa2dccd2a6a3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type for representing one of the cartesian directions.  <a href="sxbp_8h.html#a432c1738056ae8f9c53aa2dccd2a6a3a">More...</a><br /></td></tr>
<tr class="separator:a432c1738056ae8f9c53aa2dccd2a6a3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7be96b496d7a59d1f85e0d4d82afa625"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sxbp_8h.html#a7be96b496d7a59d1f85e0d4d82afa625">sxbp_refine_method_t</a> { <br />
&#160;&#160;<a class="el" href="sxbp_8h.html#a7be96b496d7a59d1f85e0d4d82afa625a3dfb3fcc73882f03833f05da34a07110">SXBP_REFINE_METHOD_ANY</a> = 0u, 
<a class="el" href="sxbp_8h.html#a7be96b496d7a59d1f85e0d4d82afa625a80c26785fa30a38aa4355f5c7fa993bb">SXBP_REFINE_METHOD_GROW_FROM_START</a>, 
<a class="el" href="sxbp_8h.html#a7be96b496d7a59d1f85e0d4d82afa625adc0c1f9ef4f0b2c2fede4b4289209544">SXBP_REFINE_METHOD_SHRINK_FROM_END</a>, 
<a class="el" href="sxbp_8h.html#a7be96b496d7a59d1f85e0d4d82afa625ab4b8185d084935417e096d7aeffd352b">SXBP_REFINE_METHOD_RESERVED_START</a> = 10u, 
<br />
&#160;&#160;<a class="el" href="sxbp_8h.html#a7be96b496d7a59d1f85e0d4d82afa625a2807e4b1afc774040cb1d322643e3163">SXBP_REFINE_METHOD_RESERVED_END</a> = 255u
<br />
 }</td></tr>
<tr class="memdesc:a7be96b496d7a59d1f85e0d4d82afa625"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to specify which figure refinement method should be used.  <a href="sxbp_8h.html#a7be96b496d7a59d1f85e0d4d82afa625">More...</a><br /></td></tr>
<tr class="separator:a7be96b496d7a59d1f85e0d4d82afa625"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adba112e91a18b8f807ce639167da1150"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sxbp_8h.html#adba112e91a18b8f807ce639167da1150">sxbp_result_t</a> { <br />
&#160;&#160;<a class="el" href="sxbp_8h.html#adba112e91a18b8f807ce639167da1150ace02951a3fbfb33051748700e0f6c98c">SXBP_RESULT_UNKNOWN</a> = 0u, 
<a class="el" href="sxbp_8h.html#adba112e91a18b8f807ce639167da1150aa1fd9ce896d405a99cba6130c2ce7532">SXBP_RESULT_OK</a>, 
<a class="el" href="sxbp_8h.html#adba112e91a18b8f807ce639167da1150a832ec3b1bd395ae071217467d3156fb5">SXBP_RESULT_FAIL_MEMORY</a>, 
<a class="el" href="sxbp_8h.html#adba112e91a18b8f807ce639167da1150a1493c0db989bfb4c7e6cce85ab84db7a">SXBP_RESULT_FAIL_PRECONDITION</a>, 
<br />
&#160;&#160;<a class="el" href="sxbp_8h.html#adba112e91a18b8f807ce639167da1150acb6eca830ea82103746158b6781e8a02">SXBP_RESULT_FAIL_IO</a>, 
<a class="el" href="sxbp_8h.html#adba112e91a18b8f807ce639167da1150af876a064c16b82db165e705e1129d718">SXBP_RESULT_FAIL_UNIMPLEMENTED</a>, 
<a class="el" href="sxbp_8h.html#adba112e91a18b8f807ce639167da1150a060c2fccc7bab91739fa5a35296efdac">SXBP_RESULT_RESERVED_START</a>, 
<a class="el" href="sxbp_8h.html#adba112e91a18b8f807ce639167da1150a2311791201f06c5d2434ae151ae266e8">SXBP_RESULT_RESERVED_END</a> = 255u
<br />
 }</td></tr>
<tr class="memdesc:adba112e91a18b8f807ce639167da1150"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to represent success/failure states for certain functions in SXBP.  <a href="sxbp_8h.html#adba112e91a18b8f807ce639167da1150">More...</a><br /></td></tr>
<tr class="separator:adba112e91a18b8f807ce639167da1150"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a5bf81084882fe9eca1bc906122361dfa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sxbp_8h.html#a5bf81084882fe9eca1bc906122361dfa">sxbp_success</a> (<a class="el" href="sxbp_8h.html#adba112e91a18b8f807ce639167da1150">sxbp_result_t</a> state)</td></tr>
<tr class="memdesc:a5bf81084882fe9eca1bc906122361dfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns if a given <code>sxbp_result_t</code> is successful or not.  <a href="#a5bf81084882fe9eca1bc906122361dfa">More...</a><br /></td></tr>
<tr class="separator:a5bf81084882fe9eca1bc906122361dfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91ae7eed7e8b33bcbf64b5aba343f951"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sxbp_8h.html#a91ae7eed7e8b33bcbf64b5aba343f951">sxbp_check</a> (<a class="el" href="sxbp_8h.html#adba112e91a18b8f807ce639167da1150">sxbp_result_t</a> state, <a class="el" href="sxbp_8h.html#adba112e91a18b8f807ce639167da1150">sxbp_result_t</a> *const report_to)</td></tr>
<tr class="memdesc:a91ae7eed7e8b33bcbf64b5aba343f951"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a given <code>sxbp_result_t</code> is successful or not.  <a href="#a91ae7eed7e8b33bcbf64b5aba343f951">More...</a><br /></td></tr>
<tr class="separator:a91ae7eed7e8b33bcbf64b5aba343f951"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f40a6570c4ccbc99bb46ca26d530bf7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsxbp__buffer__t.html">sxbp_buffer_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sxbp_8h.html#a7f40a6570c4ccbc99bb46ca26d530bf7">sxbp_blank_buffer</a> (void)</td></tr>
<tr class="memdesc:a7f40a6570c4ccbc99bb46ca26d530bf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a blank empty buffer.  <a href="#a7f40a6570c4ccbc99bb46ca26d530bf7">More...</a><br /></td></tr>
<tr class="separator:a7f40a6570c4ccbc99bb46ca26d530bf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fa7a4bf7434241c8e0fe4de8e20b1ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sxbp_8h.html#adba112e91a18b8f807ce639167da1150">sxbp_result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sxbp_8h.html#a8fa7a4bf7434241c8e0fe4de8e20b1ed">sxbp_init_buffer</a> (<a class="el" href="structsxbp__buffer__t.html">sxbp_buffer_t</a> *const buffer)</td></tr>
<tr class="memdesc:a8fa7a4bf7434241c8e0fe4de8e20b1ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to allocate memory for the bytes of the given buffer.  <a href="#a8fa7a4bf7434241c8e0fe4de8e20b1ed">More...</a><br /></td></tr>
<tr class="separator:a8fa7a4bf7434241c8e0fe4de8e20b1ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43703195f30ced7c0799c83634309098"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sxbp_8h.html#adba112e91a18b8f807ce639167da1150">sxbp_result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sxbp_8h.html#a43703195f30ced7c0799c83634309098">sxbp_resize_buffer</a> (<a class="el" href="structsxbp__buffer__t.html">sxbp_buffer_t</a> *const buffer, size_t size)</td></tr>
<tr class="memdesc:a43703195f30ced7c0799c83634309098"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to resize the given buffer.  <a href="#a43703195f30ced7c0799c83634309098">More...</a><br /></td></tr>
<tr class="separator:a43703195f30ced7c0799c83634309098"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ec9ce15ee887f4a8f20a9e57f4bb245"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sxbp_8h.html#a7ec9ce15ee887f4a8f20a9e57f4bb245">sxbp_free_buffer</a> (<a class="el" href="structsxbp__buffer__t.html">sxbp_buffer_t</a> *const buffer)</td></tr>
<tr class="memdesc:a7ec9ce15ee887f4a8f20a9e57f4bb245"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deallocates any allocated memory for the bytes of the given buffer.  <a href="#a7ec9ce15ee887f4a8f20a9e57f4bb245">More...</a><br /></td></tr>
<tr class="separator:a7ec9ce15ee887f4a8f20a9e57f4bb245"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d7afdce1e0cb8d73e1cd350dbd48ba4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sxbp_8h.html#adba112e91a18b8f807ce639167da1150">sxbp_result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sxbp_8h.html#a1d7afdce1e0cb8d73e1cd350dbd48ba4">sxbp_copy_buffer</a> (const <a class="el" href="structsxbp__buffer__t.html">sxbp_buffer_t</a> *const from, <a class="el" href="structsxbp__buffer__t.html">sxbp_buffer_t</a> *const to)</td></tr>
<tr class="memdesc:a1d7afdce1e0cb8d73e1cd350dbd48ba4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to copy one buffer to another.  <a href="#a1d7afdce1e0cb8d73e1cd350dbd48ba4">More...</a><br /></td></tr>
<tr class="separator:a1d7afdce1e0cb8d73e1cd350dbd48ba4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e14a8a602ee31bac2099ce1dcd63687"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sxbp_8h.html#adba112e91a18b8f807ce639167da1150">sxbp_result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sxbp_8h.html#a2e14a8a602ee31bac2099ce1dcd63687">sxbp_buffer_from_file</a> (FILE *file_handle, <a class="el" href="structsxbp__buffer__t.html">sxbp_buffer_t</a> *const buffer)</td></tr>
<tr class="memdesc:a2e14a8a602ee31bac2099ce1dcd63687"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to read the contents of the given file into the given buffer.  <a href="#a2e14a8a602ee31bac2099ce1dcd63687">More...</a><br /></td></tr>
<tr class="separator:a2e14a8a602ee31bac2099ce1dcd63687"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8da6e99258fc951fbd322989cad9367e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sxbp_8h.html#adba112e91a18b8f807ce639167da1150">sxbp_result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sxbp_8h.html#a8da6e99258fc951fbd322989cad9367e">sxbp_buffer_to_file</a> (const <a class="el" href="structsxbp__buffer__t.html">sxbp_buffer_t</a> *const buffer, FILE *file_handle)</td></tr>
<tr class="memdesc:a8da6e99258fc951fbd322989cad9367e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to write the contents of the given buffer to the given file.  <a href="#a8da6e99258fc951fbd322989cad9367e">More...</a><br /></td></tr>
<tr class="separator:a8da6e99258fc951fbd322989cad9367e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61e8b2071ce321c984ca81d583baa646"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsxbp__figure__t.html">sxbp_figure_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sxbp_8h.html#a61e8b2071ce321c984ca81d583baa646">sxbp_blank_figure</a> (void)</td></tr>
<tr class="memdesc:a61e8b2071ce321c984ca81d583baa646"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a blank empty figure.  <a href="#a61e8b2071ce321c984ca81d583baa646">More...</a><br /></td></tr>
<tr class="separator:a61e8b2071ce321c984ca81d583baa646"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09642f13e8ad00975c00040465431e92"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sxbp_8h.html#adba112e91a18b8f807ce639167da1150">sxbp_result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sxbp_8h.html#a09642f13e8ad00975c00040465431e92">sxbp_init_figure</a> (<a class="el" href="structsxbp__figure__t.html">sxbp_figure_t</a> *const figure)</td></tr>
<tr class="memdesc:a09642f13e8ad00975c00040465431e92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to allocate memory for dynamic members of the given figure.  <a href="#a09642f13e8ad00975c00040465431e92">More...</a><br /></td></tr>
<tr class="separator:a09642f13e8ad00975c00040465431e92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3a2fff0717d9ba747032771e13476d3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sxbp_8h.html#ab3a2fff0717d9ba747032771e13476d3">sxbp_free_figure</a> (<a class="el" href="structsxbp__figure__t.html">sxbp_figure_t</a> *const figure)</td></tr>
<tr class="memdesc:ab3a2fff0717d9ba747032771e13476d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deallocates any allocated memory for the given figure.  <a href="#ab3a2fff0717d9ba747032771e13476d3">More...</a><br /></td></tr>
<tr class="separator:ab3a2fff0717d9ba747032771e13476d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95329a2cc3a843cdf616fd32f43b33de"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sxbp_8h.html#adba112e91a18b8f807ce639167da1150">sxbp_result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sxbp_8h.html#a95329a2cc3a843cdf616fd32f43b33de">sxbp_copy_figure</a> (const <a class="el" href="structsxbp__figure__t.html">sxbp_figure_t</a> *const from, <a class="el" href="structsxbp__figure__t.html">sxbp_figure_t</a> *const to)</td></tr>
<tr class="memdesc:a95329a2cc3a843cdf616fd32f43b33de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to copy one figure to another.  <a href="#a95329a2cc3a843cdf616fd32f43b33de">More...</a><br /></td></tr>
<tr class="separator:a95329a2cc3a843cdf616fd32f43b33de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad066537a2d4c7eb2acffc0720ee07e1f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsxbp__bitmap__t.html">sxbp_bitmap_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sxbp_8h.html#ad066537a2d4c7eb2acffc0720ee07e1f">sxbp_blank_bitmap</a> (void)</td></tr>
<tr class="memdesc:ad066537a2d4c7eb2acffc0720ee07e1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a blank empty bitmap.  <a href="#ad066537a2d4c7eb2acffc0720ee07e1f">More...</a><br /></td></tr>
<tr class="separator:ad066537a2d4c7eb2acffc0720ee07e1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdc87c362fc334c853e15d1e94aef706"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sxbp_8h.html#adba112e91a18b8f807ce639167da1150">sxbp_result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sxbp_8h.html#acdc87c362fc334c853e15d1e94aef706">sxbp_init_bitmap</a> (<a class="el" href="structsxbp__bitmap__t.html">sxbp_bitmap_t</a> *const bitmap)</td></tr>
<tr class="memdesc:acdc87c362fc334c853e15d1e94aef706"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to allocate memory for the pixels of the given bitmap.  <a href="#acdc87c362fc334c853e15d1e94aef706">More...</a><br /></td></tr>
<tr class="separator:acdc87c362fc334c853e15d1e94aef706"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4556854f1085883903ddc12b742e6433"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sxbp_8h.html#a4556854f1085883903ddc12b742e6433">sxbp_free_bitmap</a> (<a class="el" href="structsxbp__bitmap__t.html">sxbp_bitmap_t</a> *const bitmap)</td></tr>
<tr class="memdesc:a4556854f1085883903ddc12b742e6433"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deallocates any allocated memory for the pixels of the given bitmap.  <a href="#a4556854f1085883903ddc12b742e6433">More...</a><br /></td></tr>
<tr class="separator:a4556854f1085883903ddc12b742e6433"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ef9bb3ec5f3f059fcf717b865fe88b8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sxbp_8h.html#adba112e91a18b8f807ce639167da1150">sxbp_result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sxbp_8h.html#a1ef9bb3ec5f3f059fcf717b865fe88b8">sxbp_copy_bitmap</a> (const <a class="el" href="structsxbp__bitmap__t.html">sxbp_bitmap_t</a> *const from, <a class="el" href="structsxbp__bitmap__t.html">sxbp_bitmap_t</a> *const to)</td></tr>
<tr class="memdesc:a1ef9bb3ec5f3f059fcf717b865fe88b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to copy one bitmap to another.  <a href="#a1ef9bb3ec5f3f059fcf717b865fe88b8">More...</a><br /></td></tr>
<tr class="separator:a1ef9bb3ec5f3f059fcf717b865fe88b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c7e90107e0cdb6426a834cb9fe6191f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sxbp_8h.html#adba112e91a18b8f807ce639167da1150">sxbp_result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sxbp_8h.html#a8c7e90107e0cdb6426a834cb9fe6191f">sxbp_begin_figure</a> (const <a class="el" href="structsxbp__buffer__t.html">sxbp_buffer_t</a> *const data, const <a class="el" href="structsxbp__begin__figure__options__t.html">sxbp_begin_figure_options_t</a> *const options, <a class="el" href="structsxbp__figure__t.html">sxbp_figure_t</a> *const figure)</td></tr>
<tr class="memdesc:a8c7e90107e0cdb6426a834cb9fe6191f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the given binary data into an early-draft SXBP figure.  <a href="#a8c7e90107e0cdb6426a834cb9fe6191f">More...</a><br /></td></tr>
<tr class="separator:a8c7e90107e0cdb6426a834cb9fe6191f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fed45c99b756b15baf9bd6f6eef55a7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sxbp_8h.html#adba112e91a18b8f807ce639167da1150">sxbp_result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sxbp_8h.html#a7fed45c99b756b15baf9bd6f6eef55a7">sxbp_refine_figure</a> (<a class="el" href="structsxbp__figure__t.html">sxbp_figure_t</a> *const figure, const <a class="el" href="structsxbp__refine__figure__options__t.html">sxbp_refine_figure_options_t</a> *const options)</td></tr>
<tr class="memdesc:a7fed45c99b756b15baf9bd6f6eef55a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Refines the line lengths of the given SXBP figure.  <a href="#a7fed45c99b756b15baf9bd6f6eef55a7">More...</a><br /></td></tr>
<tr class="separator:a7fed45c99b756b15baf9bd6f6eef55a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c80041f60823f417a1a4d61fee188b5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sxbp_8h.html#adba112e91a18b8f807ce639167da1150">sxbp_result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sxbp_8h.html#a9c80041f60823f417a1a4d61fee188b5">sxbp_dump_figure</a> (const <a class="el" href="structsxbp__figure__t.html">sxbp_figure_t</a> *const figure, <a class="el" href="structsxbp__buffer__t.html">sxbp_buffer_t</a> *const buffer)</td></tr>
<tr class="memdesc:a9c80041f60823f417a1a4d61fee188b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialises the given figure to data, stored in the given buffer.  <a href="#a9c80041f60823f417a1a4d61fee188b5">More...</a><br /></td></tr>
<tr class="separator:a9c80041f60823f417a1a4d61fee188b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e13bef18d24dc75282c6dd2d45d9284"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sxbp_8h.html#adba112e91a18b8f807ce639167da1150">sxbp_result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sxbp_8h.html#a0e13bef18d24dc75282c6dd2d45d9284">sxbp_load_figure</a> (const <a class="el" href="structsxbp__buffer__t.html">sxbp_buffer_t</a> *const buffer, <a class="el" href="structsxbp__figure__t.html">sxbp_figure_t</a> *const figure)</td></tr>
<tr class="memdesc:a0e13bef18d24dc75282c6dd2d45d9284"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to deserialise an SXBP figure from the given buffer.  <a href="#a0e13bef18d24dc75282c6dd2d45d9284">More...</a><br /></td></tr>
<tr class="separator:a0e13bef18d24dc75282c6dd2d45d9284"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5338e9ef3aafdc1d5aa13d0969e0d654"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sxbp_8h.html#adba112e91a18b8f807ce639167da1150">sxbp_result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sxbp_8h.html#a5338e9ef3aafdc1d5aa13d0969e0d654">sxbp_render_figure_to_bitmap</a> (const <a class="el" href="structsxbp__figure__t.html">sxbp_figure_t</a> *const figure, <a class="el" href="structsxbp__bitmap__t.html">sxbp_bitmap_t</a> *const bitmap)</td></tr>
<tr class="memdesc:a5338e9ef3aafdc1d5aa13d0969e0d654"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rasterises an image of the given figure to a basic bitmap object.  <a href="#a5338e9ef3aafdc1d5aa13d0969e0d654">More...</a><br /></td></tr>
<tr class="separator:a5338e9ef3aafdc1d5aa13d0969e0d654"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7a36f65cec14ede4ba02eb7cee1bdb5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sxbp_8h.html#adba112e91a18b8f807ce639167da1150">sxbp_result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sxbp_8h.html#ad7a36f65cec14ede4ba02eb7cee1bdb5">sxbp_render_figure</a> (const <a class="el" href="structsxbp__figure__t.html">sxbp_figure_t</a> *const figure, <a class="el" href="structsxbp__buffer__t.html">sxbp_buffer_t</a> *const buffer, <a class="el" href="sxbp_8h.html#a6190ffd788551f95618ccb01bf753723">sxbp_figure_renderer_t</a> render_callback, const <a class="el" href="structsxbp__render__options__t.html">sxbp_render_options_t</a> *const render_options, const void *render_callback_options)</td></tr>
<tr class="memdesc:ad7a36f65cec14ede4ba02eb7cee1bdb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renders an image of the given figure, using the given render callback.  <a href="#ad7a36f65cec14ede4ba02eb7cee1bdb5">More...</a><br /></td></tr>
<tr class="separator:ad7a36f65cec14ede4ba02eb7cee1bdb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3fe98531a58171ad2c59cf18a92a9e5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sxbp_8h.html#adba112e91a18b8f807ce639167da1150">sxbp_result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sxbp_8h.html#aa3fe98531a58171ad2c59cf18a92a9e5">sxbp_render_figure_to_null</a> (const <a class="el" href="structsxbp__figure__t.html">sxbp_figure_t</a> *const figure, <a class="el" href="structsxbp__buffer__t.html">sxbp_buffer_t</a> *const buffer, const <a class="el" href="structsxbp__render__options__t.html">sxbp_render_options_t</a> *const render_options, const void *render_callback_options)</td></tr>
<tr class="memdesc:aa3fe98531a58171ad2c59cf18a92a9e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">A dummy renderer function that does nothing.  <a href="#aa3fe98531a58171ad2c59cf18a92a9e5">More...</a><br /></td></tr>
<tr class="separator:aa3fe98531a58171ad2c59cf18a92a9e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeab49c9531b7030e4e5809fa39d58685"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sxbp_8h.html#adba112e91a18b8f807ce639167da1150">sxbp_result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sxbp_8h.html#aeab49c9531b7030e4e5809fa39d58685">sxbp_render_figure_to_pbm</a> (const <a class="el" href="structsxbp__figure__t.html">sxbp_figure_t</a> *const figure, <a class="el" href="structsxbp__buffer__t.html">sxbp_buffer_t</a> *const buffer, const <a class="el" href="structsxbp__render__options__t.html">sxbp_render_options_t</a> *const render_options, const void *render_callback_options)</td></tr>
<tr class="memdesc:aeab49c9531b7030e4e5809fa39d58685"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renders figures to PBM images.  <a href="#aeab49c9531b7030e4e5809fa39d58685">More...</a><br /></td></tr>
<tr class="separator:aeab49c9531b7030e4e5809fa39d58685"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affaa6bf0f878f3ffbcc5ae66ff4a1b17"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sxbp_8h.html#adba112e91a18b8f807ce639167da1150">sxbp_result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sxbp_8h.html#affaa6bf0f878f3ffbcc5ae66ff4a1b17">sxbp_render_figure_to_svg</a> (const <a class="el" href="structsxbp__figure__t.html">sxbp_figure_t</a> *const figure, <a class="el" href="structsxbp__buffer__t.html">sxbp_buffer_t</a> *const buffer, const <a class="el" href="structsxbp__render__options__t.html">sxbp_render_options_t</a> *const render_options, const void *render_callback_options)</td></tr>
<tr class="memdesc:affaa6bf0f878f3ffbcc5ae66ff4a1b17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renders figures to SVG images.  <a href="#affaa6bf0f878f3ffbcc5ae66ff4a1b17">More...</a><br /></td></tr>
<tr class="separator:affaa6bf0f878f3ffbcc5ae66ff4a1b17"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a65c0388820516f27d300efabab54ae10"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structsxbp__version__t.html">sxbp_version_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sxbp_8h.html#a65c0388820516f27d300efabab54ae10">SXBP_VERSION</a></td></tr>
<tr class="memdesc:a65c0388820516f27d300efabab54ae10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores the current version of sxbp.  <a href="#a65c0388820516f27d300efabab54ae10">More...</a><br /></td></tr>
<tr class="separator:a65c0388820516f27d300efabab54ae10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7627a48c48e06fa278e53bdc91376cf"><td class="memItemLeft" align="right" valign="top">const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sxbp_8h.html#ac7627a48c48e06fa278e53bdc91376cf">SXBP_BEGIN_BUFFER_MAX_SIZE</a></td></tr>
<tr class="memdesc:ac7627a48c48e06fa278e53bdc91376cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum size of buffer that can be used to begin a figure.  <a href="#ac7627a48c48e06fa278e53bdc91376cf">More...</a><br /></td></tr>
<tr class="separator:ac7627a48c48e06fa278e53bdc91376cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc8fba92e800ddfa471dac664376abae"><td class="memItemLeft" align="right" valign="top"><a id="adc8fba92e800ddfa471dac664376abae"></a>
const <a class="el" href="structsxbp__begin__figure__options__t.html">sxbp_begin_figure_options_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sxbp_8h.html#adc8fba92e800ddfa471dac664376abae">SXBP_BEGIN_FIGURE_OPTIONS_DEFAULT</a></td></tr>
<tr class="memdesc:adc8fba92e800ddfa471dac664376abae"><td class="mdescLeft">&#160;</td><td class="mdescRight">The default options used for <code><a class="el" href="structsxbp__figure__t.html#a8c7e90107e0cdb6426a834cb9fe6191f" title="Converts the given binary data into an early-draft SXBP figure. ">sxbp_begin_figure()</a></code> <br /></td></tr>
<tr class="separator:adc8fba92e800ddfa471dac664376abae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3195def0eaf8e9e25bf2a7eaec5f96c6"><td class="memItemLeft" align="right" valign="top"><a id="a3195def0eaf8e9e25bf2a7eaec5f96c6"></a>
const <a class="el" href="sxbp_8h.html#a7be96b496d7a59d1f85e0d4d82afa625">sxbp_refine_method_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sxbp_8h.html#a3195def0eaf8e9e25bf2a7eaec5f96c6">SXBP_REFINE_METHOD_DEFAULT</a></td></tr>
<tr class="memdesc:a3195def0eaf8e9e25bf2a7eaec5f96c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The default figure refinement method used by <code><a class="el" href="structsxbp__figure__t.html#a7fed45c99b756b15baf9bd6f6eef55a7" title="Refines the line lengths of the given SXBP figure. ">sxbp_refine_figure()</a></code> <br /></td></tr>
<tr class="separator:a3195def0eaf8e9e25bf2a7eaec5f96c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This header file provides the entire public API of sxbp. </p>
<dl class="section author"><dt>Author</dt><dd>Joshua Saxby <a href="#" onclick="location.href='mai'+'lto:'+'jos'+'hu'+'a.a'+'.s'+'axb'+'y@'+'gma'+'il'+'.co'+'m'; return false;">joshu<span style="display: none;">.nosp@m.</span>a.a.<span style="display: none;">.nosp@m.</span>saxby<span style="display: none;">.nosp@m.</span>@gma<span style="display: none;">.nosp@m.</span>il.co<span style="display: none;">.nosp@m.</span>m</a> </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2016-2017, 2018</dd></dl>
<dl class="section copyright"><dt>Copyright</dt><dd>Copyright (C) Joshua Saxby 2016-2017, 2018</dd>
<dd>
This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0. If a copy of the MPL was not distributed with this file, You can obtain one at <a href="http://mozilla.org/MPL/2.0/">http://mozilla.org/MPL/2.0/</a>. </dd></dl>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="ad10ba5c361be12daef8ed43bd55eb753"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad10ba5c361be12daef8ed43bd55eb753">&#9670;&nbsp;</a></span>sxbp_length_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef uint32_t <a class="el" href="sxbp_8h.html#ad10ba5c361be12daef8ed43bd55eb753">sxbp_length_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type for representing the length of a line segment of a spiral. </p>
<dl class="section note"><dt>Note</dt><dd>Although the width of this type is 32 bits, it is actually only 30 bits when used in the sxbp_spiral_t struct type. This is because here it is a bitfield field with 30 bits allocated to it. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>v0.27.0 </dd></dl>

</div>
</div>
<a id="a64e2ae7e91a4c4f52af7487f7a32d0d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64e2ae7e91a4c4f52af7487f7a32d0d2">&#9670;&nbsp;</a></span>sxbp_figure_size_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef uint32_t <a class="el" href="sxbp_8h.html#a64e2ae7e91a4c4f52af7487f7a32d0d2">sxbp_figure_size_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type for representing the size of an SXBP figure. </p>
<p>In other words, this is the type for storing the count of lines in the figure. </p><dl class="section since"><dt>Since</dt><dd>v0.54.0 </dd></dl>

</div>
</div>
<a id="a1645a3341032b7107ed60f9be72b6f70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1645a3341032b7107ed60f9be72b6f70">&#9670;&nbsp;</a></span>sxbp_figure_dimension_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef uint32_t <a class="el" href="sxbp_8h.html#a1645a3341032b7107ed60f9be72b6f70">sxbp_figure_dimension_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type for representing the width or height of a rendered SXBP figure. </p>
<p>This type is that used for representing the width and height of rendered images of sxbp figures. </p><dl class="section since"><dt>Since</dt><dd>v0.54.0 </dd></dl>

</div>
</div>
<a id="a6190ffd788551f95618ccb01bf753723"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6190ffd788551f95618ccb01bf753723">&#9670;&nbsp;</a></span>sxbp_figure_renderer_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="sxbp_8h.html#adba112e91a18b8f807ce639167da1150">sxbp_result_t</a>(*  sxbp_figure_renderer_t) (const <a class="el" href="structsxbp__figure__t.html">sxbp_figure_t</a> *const figure, <a class="el" href="structsxbp__buffer__t.html">sxbp_buffer_t</a> *const buffer, const <a class="el" href="structsxbp__render__options__t.html">sxbp_render_options_t</a> *const render_options, const void *render_callback_options)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A convenience typedef for a callback function that renders a figure. </p>
<p>This is used in <code><a class="el" href="structsxbp__figure__t.html#ad7a36f65cec14ede4ba02eb7cee1bdb5" title="Renders an image of the given figure, using the given render callback. ">sxbp_render_figure()</a></code> and should render a figure to an image, serialised and stored in the given buffer. </p><dl class="todo"><dt><b><a class="el" href="todo.html#_todo000002">Todo:</a></b></dt><dd>Try and use Doxygen's <code>at-param</code> syntax to document the arguments and use <code>at-returns</code> to document the return details. </dd></dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a432c1738056ae8f9c53aa2dccd2a6a3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a432c1738056ae8f9c53aa2dccd2a6a3a">&#9670;&nbsp;</a></span>sxbp_direction_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="sxbp_8h.html#a432c1738056ae8f9c53aa2dccd2a6a3a">sxbp_direction_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type for representing one of the cartesian directions. </p>
<dl class="section since"><dt>Since</dt><dd>v0.54.0 </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a432c1738056ae8f9c53aa2dccd2a6a3aa85f442e9a2fd78d9d8ad911b4e85a0ac"></a>SXBP_UP&#160;</td><td class="fielddoc"><p>The cartesian direction 'UP' </p>
</td></tr>
<tr><td class="fieldname"><a id="a432c1738056ae8f9c53aa2dccd2a6a3aa31f3f25c44e418c6a6784cfb22d3b3d2"></a>SXBP_RIGHT&#160;</td><td class="fielddoc"><p>The cartesian direction 'RIGHT' </p>
</td></tr>
<tr><td class="fieldname"><a id="a432c1738056ae8f9c53aa2dccd2a6a3aa71675a500a7a7433b603bbe96c258903"></a>SXBP_DOWN&#160;</td><td class="fielddoc"><p>The cartesian direction 'DOWN' </p>
</td></tr>
<tr><td class="fieldname"><a id="a432c1738056ae8f9c53aa2dccd2a6a3aa74ae9ed8847a8a29bc952b0f9e576e0c"></a>SXBP_LEFT&#160;</td><td class="fielddoc"><p>The cartesian direction 'LEFT' </p>
</td></tr>
</table>

</div>
</div>
<a id="a7be96b496d7a59d1f85e0d4d82afa625"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7be96b496d7a59d1f85e0d4d82afa625">&#9670;&nbsp;</a></span>sxbp_refine_method_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="sxbp_8h.html#a7be96b496d7a59d1f85e0d4d82afa625">sxbp_refine_method_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Used to specify which figure refinement method should be used. </p>
<p>There are a few different ways that a figure can be 'refined' to be smaller, this type is used to represent all of the methods currently implemented by the library </p><dl class="section note"><dt>Note</dt><dd>Values <code>SXBP_REFINE_METHOD_RESERVED_START</code> through <code>SXBP_REFINE_METHOD_RESERVED_END</code> inclusive are reserved for future use. If a value equal to or greater than <code>SXBP_REFINE_METHOD_RESERVED_START</code> is encountered, the caller can assume that either a new code for which it has no definition has been returned, or that the value is garbage. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>v0.54.0 </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a7be96b496d7a59d1f85e0d4d82afa625a3dfb3fcc73882f03833f05da34a07110"></a>SXBP_REFINE_METHOD_ANY&#160;</td><td class="fielddoc"><p>use any method, the default </p>
</td></tr>
<tr><td class="fieldname"><a id="a7be96b496d7a59d1f85e0d4d82afa625a80c26785fa30a38aa4355f5c7fa993bb"></a>SXBP_REFINE_METHOD_GROW_FROM_START&#160;</td><td class="fielddoc"><p>the original refinement method </p>
</td></tr>
<tr><td class="fieldname"><a id="a7be96b496d7a59d1f85e0d4d82afa625adc0c1f9ef4f0b2c2fede4b4289209544"></a>SXBP_REFINE_METHOD_SHRINK_FROM_END&#160;</td><td class="fielddoc"><p>the current refinement method </p>
</td></tr>
<tr><td class="fieldname"><a id="a7be96b496d7a59d1f85e0d4d82afa625ab4b8185d084935417e096d7aeffd352b"></a>SXBP_REFINE_METHOD_RESERVED_START&#160;</td><td class="fielddoc"><p>reserved for future use </p>
</td></tr>
<tr><td class="fieldname"><a id="a7be96b496d7a59d1f85e0d4d82afa625a2807e4b1afc774040cb1d322643e3163"></a>SXBP_REFINE_METHOD_RESERVED_END&#160;</td><td class="fielddoc"><p>reserved for future use </p>
</td></tr>
</table>

</div>
</div>
<a id="adba112e91a18b8f807ce639167da1150"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adba112e91a18b8f807ce639167da1150">&#9670;&nbsp;</a></span>sxbp_result_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="sxbp_8h.html#adba112e91a18b8f807ce639167da1150">sxbp_result_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Used to represent success/failure states for certain functions in SXBP. </p>
<p>For functions which can encounter error conditions, this type enumerates the possible error conditions that can occur </p><dl class="section note"><dt>Note</dt><dd>Values <code>SXBP_RESULT_RESERVED_START</code> through <code>SXBP_RESULT_RESERVED_END</code> inclusive are reserved for future use. If a value equal to or greater than <code>SXBP_RESULT_RESERVED_START</code> is encountered, the caller can assume that either a new code for which it has no definition has been returned, or that the value is garbage. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>v0.54.0 </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="adba112e91a18b8f807ce639167da1150ace02951a3fbfb33051748700e0f6c98c"></a>SXBP_RESULT_UNKNOWN&#160;</td><td class="fielddoc"><p>unknown, the default </p>
</td></tr>
<tr><td class="fieldname"><a id="adba112e91a18b8f807ce639167da1150aa1fd9ce896d405a99cba6130c2ce7532"></a>SXBP_RESULT_OK&#160;</td><td class="fielddoc"><p>success </p>
</td></tr>
<tr><td class="fieldname"><a id="adba112e91a18b8f807ce639167da1150a832ec3b1bd395ae071217467d3156fb5"></a>SXBP_RESULT_FAIL_MEMORY&#160;</td><td class="fielddoc"><p>failure to allocate or reallocate memory </p>
</td></tr>
<tr><td class="fieldname"><a id="adba112e91a18b8f807ce639167da1150a1493c0db989bfb4c7e6cce85ab84db7a"></a>SXBP_RESULT_FAIL_PRECONDITION&#160;</td><td class="fielddoc"><p>a preconditional check failed </p>
</td></tr>
<tr><td class="fieldname"><a id="adba112e91a18b8f807ce639167da1150acb6eca830ea82103746158b6781e8a02"></a>SXBP_RESULT_FAIL_IO&#160;</td><td class="fielddoc"><p>an input/output operation failed </p>
</td></tr>
<tr><td class="fieldname"><a id="adba112e91a18b8f807ce639167da1150af876a064c16b82db165e705e1129d718"></a>SXBP_RESULT_FAIL_UNIMPLEMENTED&#160;</td><td class="fielddoc"><p>requested action is not implemented </p>
</td></tr>
<tr><td class="fieldname"><a id="adba112e91a18b8f807ce639167da1150a060c2fccc7bab91739fa5a35296efdac"></a>SXBP_RESULT_RESERVED_START&#160;</td><td class="fielddoc"><p>reserved for future use </p>
</td></tr>
<tr><td class="fieldname"><a id="adba112e91a18b8f807ce639167da1150a2311791201f06c5d2434ae151ae266e8"></a>SXBP_RESULT_RESERVED_END&#160;</td><td class="fielddoc"><p>reserved for future use </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a5bf81084882fe9eca1bc906122361dfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bf81084882fe9eca1bc906122361dfa">&#9670;&nbsp;</a></span>sxbp_success()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sxbp_success </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sxbp_8h.html#adba112e91a18b8f807ce639167da1150">sxbp_result_t</a>&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns if a given <code>sxbp_result_t</code> is successful or not. </p>
<p>This is intended to be used to easily check the return status of functions in SXBP that can raise errors. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>The state to check for success/failure </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the given status code was success </dd>
<dd>
<code>false</code> if the given status code was not success </dd></dl>

</div>
</div>
<a id="a91ae7eed7e8b33bcbf64b5aba343f951"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91ae7eed7e8b33bcbf64b5aba343f951">&#9670;&nbsp;</a></span>sxbp_check()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sxbp_check </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sxbp_8h.html#adba112e91a18b8f807ce639167da1150">sxbp_result_t</a>&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sxbp_8h.html#adba112e91a18b8f807ce639167da1150">sxbp_result_t</a> *const&#160;</td>
          <td class="paramname"><em>report_to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if a given <code>sxbp_result_t</code> is successful or not. </p>
<p>This is intended to be used to easily check the return status of functions in SXBP that can raise errors. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">state</td><td>The state to check for success/failure </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">report_to</td><td>An optional pointer to a <code>sxbp_result_t</code> to store the result in, if it was failure. This is ignored if <code>NULL</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the given status code was success </dd>
<dd>
<code>false</code> if the given status code was not success </dd></dl>

</div>
</div>
<a id="a7f40a6570c4ccbc99bb46ca26d530bf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f40a6570c4ccbc99bb46ca26d530bf7">&#9670;&nbsp;</a></span>sxbp_blank_buffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsxbp__buffer__t.html">sxbp_buffer_t</a> sxbp_blank_buffer </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a blank empty buffer. </p>
<p>Ensures that all pointer fields are properly initialised to NULL </p><dl class="section return"><dt>Returns</dt><dd>An <code><a class="el" href="structsxbp__buffer__t.html" title="A simple buffer type for storing arrays of bytes. ">sxbp_buffer_t</a></code> object with all fields set to default/blank value </dd></dl>
<dl class="section since"><dt>Since</dt><dd>v0.54.0 </dd></dl>

</div>
</div>
<a id="a8fa7a4bf7434241c8e0fe4de8e20b1ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fa7a4bf7434241c8e0fe4de8e20b1ed">&#9670;&nbsp;</a></span>sxbp_init_buffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sxbp_8h.html#adba112e91a18b8f807ce639167da1150">sxbp_result_t</a> sxbp_init_buffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsxbp__buffer__t.html">sxbp_buffer_t</a> *const&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempts to allocate memory for the bytes of the given buffer. </p>
<p>Attempts to allocate the amount of memory specified by the <code>size</code> member of the buffer </p><dl class="section warning"><dt>Warning</dt><dd>It is unsafe to call this function on a buffer that has already been allocated </dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>SXBP_RESULT_OK</code> if memory was allocated successfully </dd>
<dd>
<code>SXBP_RESULT_FAIL_MEMORY</code> if memory was not allocated successfully </dd>
<dd>
<code>SXBP_RESULT_FAIL_PRECONDITION</code> if <code>buffer</code> is <code>NULL</code> </dd></dl>
<dl class="section since"><dt>Since</dt><dd>v0.54.0 </dd></dl>

</div>
</div>
<a id="a43703195f30ced7c0799c83634309098"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43703195f30ced7c0799c83634309098">&#9670;&nbsp;</a></span>sxbp_resize_buffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sxbp_8h.html#adba112e91a18b8f807ce639167da1150">sxbp_result_t</a> sxbp_resize_buffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsxbp__buffer__t.html">sxbp_buffer_t</a> *const&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempts to resize the given buffer. </p>
<p>The buffer will be grown or shrunk depending on if <code>size</code> is bigger than or less than it's existing size. If grown, the bytes beyond the extent of its previous size will be of indeterminate value. If shrunk, the bytes that lie beyond the new extent after shrinking will be lost. </p><dl class="section warning"><dt>Warning</dt><dd>It is unsafe to call this function on a buffer that has not been allocated with <code>sxbp_init_buffer</code> before. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>SXBP_RESULT_OK</code> if memory was allocated successfully </dd>
<dd>
<code>SXBP_RESULT_FAIL_MEMORY</code> if memory was not reallocated successfully </dd>
<dd>
<code>SXBP_RESULT_FAIL_PRECONDITION</code> if <code>buffer</code> or <code>buffer-&gt;bytes</code> are <code>NULL</code> </dd></dl>
<dl class="section since"><dt>Since</dt><dd>v0.54.0 </dd></dl>

</div>
</div>
<a id="a7ec9ce15ee887f4a8f20a9e57f4bb245"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ec9ce15ee887f4a8f20a9e57f4bb245">&#9670;&nbsp;</a></span>sxbp_free_buffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sxbp_free_buffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsxbp__buffer__t.html">sxbp_buffer_t</a> *const&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deallocates any allocated memory for the bytes of the given buffer. </p>
<dl class="section note"><dt>Note</dt><dd>It is safe to call this function multiple times on the same buffer </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>It is unsafe to call this function on a buffer that has been deallocated without setting the <code>bytes</code> pointer member to <code>NULL</code>. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if memory was deallocated </dd>
<dd>
<code>false</code> if memory did not need to be deallocated (this is not an error condition) </dd></dl>
<dl class="section since"><dt>Since</dt><dd>v0.54.0 </dd></dl>

</div>
</div>
<a id="a1d7afdce1e0cb8d73e1cd350dbd48ba4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d7afdce1e0cb8d73e1cd350dbd48ba4">&#9670;&nbsp;</a></span>sxbp_copy_buffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sxbp_8h.html#adba112e91a18b8f807ce639167da1150">sxbp_result_t</a> sxbp_copy_buffer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structsxbp__buffer__t.html">sxbp_buffer_t</a> *const&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsxbp__buffer__t.html">sxbp_buffer_t</a> *const&#160;</td>
          <td class="paramname"><em>to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempts to copy one buffer to another. </p>
<p>All the data is copied from the buffer such that both are entirely separate at the completion of the operation. Any data in the <code>to</code> buffer will be overwritten or erased. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">from</td><td>The buffer to copy the contents of </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">to</td><td>The buffer to copy the contents to </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>The buffer to copy the contents to must be in a consistent state, that is it must either not be allocated yet, or must be properly allocated. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>SXBP_RESULT_OK</code> if the data was copied successfully </dd>
<dd>
<code>SXBP_RESULT_FAIL_MEMORY</code> if the data was not copied successfully, in which case <code>to</code> will be empty. </dd>
<dd>
<code>SXBP_RESULT_FAIL_PRECONDITION</code> if <code>from</code> or <code>to</code> is <code>NULL</code> </dd></dl>
<dl class="section since"><dt>Since</dt><dd>v0.54.0 </dd></dl>

</div>
</div>
<a id="a2e14a8a602ee31bac2099ce1dcd63687"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e14a8a602ee31bac2099ce1dcd63687">&#9670;&nbsp;</a></span>sxbp_buffer_from_file()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sxbp_8h.html#adba112e91a18b8f807ce639167da1150">sxbp_result_t</a> sxbp_buffer_from_file </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>file_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsxbp__buffer__t.html">sxbp_buffer_t</a> *const&#160;</td>
          <td class="paramname"><em>buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempts to read the contents of the given file into the given buffer. </p>
<p>Allocates the buffer and copies all the bytes of the file into it </p><dl class="section warning"><dt>Warning</dt><dd>The file should have been opened in <code>rb</code> mode </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">file_handle</td><td>The file to read data from </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buffer</td><td>The buffer to write data to </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>SXBP_RESULT_OK</code> on successfully copying the file contents </dd>
<dd>
<code>SXBP_RESULT_FAIL_MEMORY</code> or <code>SXBP_RESULT_FAIL_IO</code> on failure to copy the file contents </dd>
<dd>
<code>SXBP_RESULT_FAIL_PRECONDITION</code> if <code>file_handle</code> or <code>buffer</code> is <code>NULL</code> </dd></dl>
<dl class="section since"><dt>Since</dt><dd>v0.54.0 </dd></dl>

</div>
</div>
<a id="a8da6e99258fc951fbd322989cad9367e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8da6e99258fc951fbd322989cad9367e">&#9670;&nbsp;</a></span>sxbp_buffer_to_file()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sxbp_8h.html#adba112e91a18b8f807ce639167da1150">sxbp_result_t</a> sxbp_buffer_to_file </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structsxbp__buffer__t.html">sxbp_buffer_t</a> *const&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>file_handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempts to write the contents of the given buffer to the given file. </p>
<p>Writes all the bytes in the buffer out to the open file </p><dl class="section warning"><dt>Warning</dt><dd>The file should have been opened in <code>wb</code> mode </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">buffer</td><td>The buffer to read data from </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">file_handle</td><td>The file to write data to </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>SXBP_RESULT_OK</code> on successfully writing the file </dd>
<dd>
<code>SXBP_RESULT_FAIL_IO</code> on failure to write the file </dd>
<dd>
<code>SXBP_RESULT_FAIL_PRECONDITION</code> if <code>buffer</code> or <code>file_handle</code> is <code>NULL</code> </dd></dl>
<dl class="section since"><dt>Since</dt><dd>v0.54.0 </dd></dl>

</div>
</div>
<a id="a61e8b2071ce321c984ca81d583baa646"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61e8b2071ce321c984ca81d583baa646">&#9670;&nbsp;</a></span>sxbp_blank_figure()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsxbp__figure__t.html">sxbp_figure_t</a> sxbp_blank_figure </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a blank empty figure. </p>
<p>Ensures that all pointer fields are properly initialised to NULL </p><dl class="section return"><dt>Returns</dt><dd>An <code><a class="el" href="structsxbp__figure__t.html" title="A structure representing an SXBP &#39;spiral&#39; figure. ">sxbp_figure_t</a></code> object with all fields set to default/blank value </dd></dl>
<dl class="section since"><dt>Since</dt><dd>v0.54.0 </dd></dl>

</div>
</div>
<a id="a09642f13e8ad00975c00040465431e92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09642f13e8ad00975c00040465431e92">&#9670;&nbsp;</a></span>sxbp_init_figure()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sxbp_8h.html#adba112e91a18b8f807ce639167da1150">sxbp_result_t</a> sxbp_init_figure </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsxbp__figure__t.html">sxbp_figure_t</a> *const&#160;</td>
          <td class="paramname"><em>figure</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempts to allocate memory for dynamic members of the given figure. </p>
<p>Attempts to allocate the number of lines specified by the <code>size</code> member of the figure, and memory for other private fields of the structure as needed. </p><dl class="section warning"><dt>Warning</dt><dd>It is unsafe to call this function on a figure that has already been allocated </dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>SXBP_RESULT_OK</code> if all memory was allocated successfully </dd>
<dd>
<code>SXBP_RESULT_FAIL_MEMORY</code> if any memory was not allocated successfully </dd>
<dd>
<code>SXBP_RESULT_FAIL_PRECONDITION</code> if <code>figure</code> is <code>NULL</code> </dd></dl>
<dl class="section since"><dt>Since</dt><dd>v0.54.0 </dd></dl>

</div>
</div>
<a id="ab3a2fff0717d9ba747032771e13476d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3a2fff0717d9ba747032771e13476d3">&#9670;&nbsp;</a></span>sxbp_free_figure()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sxbp_free_figure </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsxbp__figure__t.html">sxbp_figure_t</a> *const&#160;</td>
          <td class="paramname"><em>figure</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deallocates any allocated memory for the given figure. </p>
<dl class="section note"><dt>Note</dt><dd>It is safe to call this function multiple times on the same figure </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>It is unsafe to call this function on a figure that has had any dynamically allocated members deallocated without setting their respective pointers to <code>NULL</code>. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if any memory was deallocated </dd>
<dd>
<code>false</code> if no memory needed to be deallocated (this is not an error condition) </dd></dl>
<dl class="section since"><dt>Since</dt><dd>v0.54.0 </dd></dl>

</div>
</div>
<a id="a95329a2cc3a843cdf616fd32f43b33de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95329a2cc3a843cdf616fd32f43b33de">&#9670;&nbsp;</a></span>sxbp_copy_figure()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sxbp_8h.html#adba112e91a18b8f807ce639167da1150">sxbp_result_t</a> sxbp_copy_figure </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structsxbp__figure__t.html">sxbp_figure_t</a> *const&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsxbp__figure__t.html">sxbp_figure_t</a> *const&#160;</td>
          <td class="paramname"><em>to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempts to copy one figure to another. </p>
<p>All the data is copied from the figure such that both are entirely separate at the completion of the operation. Any data in the <code>to</code> figure will be overwritten or erased. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">from</td><td>The figure to copy the contents of </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">to</td><td>The figure to copy the contents to </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>The figure to copy the contents to must be in a consistent state, that is it must either not be allocated yet, or must be properly allocated. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>SXBP_RESULT_OK</code> if the data was copied successfully </dd>
<dd>
<code>SXBP_RESULT_FAIL_MEMORY</code> if the data was not copied successfully, in which case <code>to</code> will be empty. </dd>
<dd>
<code>SXBP_RESULT_FAIL_PRECONDITION</code> if <code>from</code> or <code>to</code> is <code>NULL</code> </dd></dl>
<dl class="section since"><dt>Since</dt><dd>v0.54.0 </dd></dl>

</div>
</div>
<a id="ad066537a2d4c7eb2acffc0720ee07e1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad066537a2d4c7eb2acffc0720ee07e1f">&#9670;&nbsp;</a></span>sxbp_blank_bitmap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsxbp__bitmap__t.html">sxbp_bitmap_t</a> sxbp_blank_bitmap </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a blank empty bitmap. </p>
<p>Ensures that all pointer fields are properly initialised to NULL </p><dl class="section return"><dt>Returns</dt><dd>An <code><a class="el" href="structsxbp__bitmap__t.html" title="Used to represent a basic 1-bit, pure black/white bitmap image. ">sxbp_bitmap_t</a></code> object with all fields set to default/blank value </dd></dl>
<dl class="section since"><dt>Since</dt><dd>v0.54.0 </dd></dl>

</div>
</div>
<a id="acdc87c362fc334c853e15d1e94aef706"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdc87c362fc334c853e15d1e94aef706">&#9670;&nbsp;</a></span>sxbp_init_bitmap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sxbp_8h.html#adba112e91a18b8f807ce639167da1150">sxbp_result_t</a> sxbp_init_bitmap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsxbp__bitmap__t.html">sxbp_bitmap_t</a> *const&#160;</td>
          <td class="paramname"><em>bitmap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempts to allocate memory for the pixels of the given bitmap. </p>
<p>Attempts to allocate the memory for the amount of pixels specified by the <code>width</code> and <code>height</code> members of the bitmap </p><dl class="section warning"><dt>Warning</dt><dd>It is unsafe to call this function on a bitmap that has already been allocated </dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>SXBP_RESULT_OK</code> if memory was allocated successfully </dd>
<dd>
<code>SXBP_RESULT_FAIL_MEMORY</code> if memory was not allocated successfully </dd>
<dd>
<code>SXBP_RESULT_FAIL_PRECONDITION</code> if <code>bitmap</code> is <code>NULL</code> </dd></dl>
<dl class="section since"><dt>Since</dt><dd>v0.54.0 </dd></dl>

</div>
</div>
<a id="a4556854f1085883903ddc12b742e6433"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4556854f1085883903ddc12b742e6433">&#9670;&nbsp;</a></span>sxbp_free_bitmap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sxbp_free_bitmap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsxbp__bitmap__t.html">sxbp_bitmap_t</a> *const&#160;</td>
          <td class="paramname"><em>bitmap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deallocates any allocated memory for the pixels of the given bitmap. </p>
<dl class="section note"><dt>Note</dt><dd>It is safe to call this function multiple times on the same bitmap </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>It is unsafe to call this function on a bitmap that has been deallocated without setting the <code>pixels</code> pointer member to <code>NULL</code>. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if memory was deallocated </dd>
<dd>
<code>false</code> if memory did not need to be deallocated (this is not an error condition) </dd></dl>
<dl class="section since"><dt>Since</dt><dd>v0.54.0 </dd></dl>

</div>
</div>
<a id="a1ef9bb3ec5f3f059fcf717b865fe88b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ef9bb3ec5f3f059fcf717b865fe88b8">&#9670;&nbsp;</a></span>sxbp_copy_bitmap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sxbp_8h.html#adba112e91a18b8f807ce639167da1150">sxbp_result_t</a> sxbp_copy_bitmap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structsxbp__bitmap__t.html">sxbp_bitmap_t</a> *const&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsxbp__bitmap__t.html">sxbp_bitmap_t</a> *const&#160;</td>
          <td class="paramname"><em>to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempts to copy one bitmap to another. </p>
<p>All the data is copied from the bitmap such that both are entirely separate at the completion of the operation. Any data in the <code>to</code> bitmap will be overwritten or erased. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">from</td><td>The bitmap to copy the contents of </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">to</td><td>The bitmap to copy the contents to </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>The bitmap to copy the contents to must be in a consistent state, that is it must either not be allocated yet, or must be properly allocated. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>SXBP_RESULT_OK</code> if the data was copied successfully </dd>
<dd>
<code>SXBP_RESULT_FAIL_MEMORY</code> if the data was not copied successfully, in which case <code>to</code> will be empty. </dd>
<dd>
<code>SXBP_RESULT_FAIL_PRECONDITION</code> if <code>from</code> or <code>to</code> is <code>NULL</code> </dd></dl>
<dl class="section since"><dt>Since</dt><dd>v0.54.0 </dd></dl>

</div>
</div>
<a id="a8c7e90107e0cdb6426a834cb9fe6191f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c7e90107e0cdb6426a834cb9fe6191f">&#9670;&nbsp;</a></span>sxbp_begin_figure()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sxbp_8h.html#adba112e91a18b8f807ce639167da1150">sxbp_result_t</a> sxbp_begin_figure </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structsxbp__buffer__t.html">sxbp_buffer_t</a> *const&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsxbp__begin__figure__options__t.html">sxbp_begin_figure_options_t</a> *const&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsxbp__figure__t.html">sxbp_figure_t</a> *const&#160;</td>
          <td class="paramname"><em>figure</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts the given binary data into an early-draft SXBP figure. </p>
<p>The data in the given buffer is converted into a sequence of spiral directions and from these an unrefined rudimentary line is plotted in the figure (by setting the directions and lengths of the figure's lines). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">data</td><td>The buffer containing data to generate the figure from </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">options</td><td>An optional options struct to specify additional options for starting the figure. This can be <code>NULL</code>, in which case the default options are used. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">figure</td><td>The figure in which to generate the line. This will be erased before data is written to it. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The shape that can be derived from this data will waste a lot of visual space and should be refined by calling <code>sxbp_refine_figure</code> </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Figures cannot be created from buffers larger than <code>SXBP_BEGIN_BUFFER_MAX_SIZE</code> &ndash; an error will be returned if this is attempted. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>SXBP_RESULT_OK</code> if the figure could be successfully generated </dd>
<dd>
<code>SXBP_RESULT_FAIL_MEMORY</code> if the figure could not be successfully generated </dd>
<dd>
<code>SXBP_RESULT_FAIL_PRECONDITION</code> if the given buffer was too large </dd>
<dd>
<code>SXBP_RESULT_FAIL_PRECONDITION</code> if <code>data</code> or <code>figure</code> is <code>NULL</code> </dd></dl>
<dl class="section since"><dt>Since</dt><dd>v0.54.0 </dd></dl>

</div>
</div>
<a id="a7fed45c99b756b15baf9bd6f6eef55a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fed45c99b756b15baf9bd6f6eef55a7">&#9670;&nbsp;</a></span>sxbp_refine_figure()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sxbp_8h.html#adba112e91a18b8f807ce639167da1150">sxbp_result_t</a> sxbp_refine_figure </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsxbp__figure__t.html">sxbp_figure_t</a> *const&#160;</td>
          <td class="paramname"><em>figure</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsxbp__refine__figure__options__t.html">sxbp_refine_figure_options_t</a> *const&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Refines the line lengths of the given SXBP figure. </p>
<p>The line lengths are adjusted to take up less space than that which are generated by <code>sxbp_begin_figure</code> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">figure</td><td>The figure to refine. This will be mutated. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">options</td><td>Optional options struct, currently used to supply a progress callback and callback context. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function will fail immediately if the SXBP figure that is passed to it has colliding lines, or no lines </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function may take a long time to execute </dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>SXBP_RESULT_OK</code> if the figure could be successfully refined </dd>
<dd>
<code>SXBP_RESULT_FAIL_PRECONDITION</code> if <code>figure</code> is <code>NULL</code> </dd>
<dd>
<code>SXBP_RESULT_FAIL_PRECONDITION</code> if called on a figure with no lines allocated </dd>
<dd>
<code>SXBP_RESULT_FAIL_UNIMPLEMENTED</code> if <code>options</code> specifies an unimplemented refinement method. </dd>
<dd>
<code>SXBP_RESULT_FAIL_MEMORY</code> if a memory allocation error occurred when refining the figure </dd></dl>
<dl class="section since"><dt>Since</dt><dd>v0.54.0 </dd></dl>

</div>
</div>
<a id="a9c80041f60823f417a1a4d61fee188b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c80041f60823f417a1a4d61fee188b5">&#9670;&nbsp;</a></span>sxbp_dump_figure()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sxbp_8h.html#adba112e91a18b8f807ce639167da1150">sxbp_result_t</a> sxbp_dump_figure </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structsxbp__figure__t.html">sxbp_figure_t</a> *const&#160;</td>
          <td class="paramname"><em>figure</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsxbp__buffer__t.html">sxbp_buffer_t</a> *const&#160;</td>
          <td class="paramname"><em>buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Serialises the given figure to data, stored in the given buffer. </p>
<p>The buffer is populated with bytes which represent the figure and from whch compatible versions of SXBP can load figures from again </p><dl class="section note"><dt>Note</dt><dd>The buffer is erased before being populated </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">figure</td><td>The figure to serialise </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buffer</td><td>The buffer to store the serialised data in </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>SXBP_RESULT_OK</code> if the figure could be successfully serialised </dd>
<dd>
<code>SXBP_RESULT_FAIL_MEMORY</code> if the figure could not be successfully serialised </dd>
<dd>
<code>SXBP_RESULT_FAIL_PRECONDITION</code> if <code>figure</code> or <code>buffer</code> is <code>NULL</code> </dd></dl>
<dl class="section since"><dt>Since</dt><dd>v0.54.0 </dd></dl>

</div>
</div>
<a id="a0e13bef18d24dc75282c6dd2d45d9284"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e13bef18d24dc75282c6dd2d45d9284">&#9670;&nbsp;</a></span>sxbp_load_figure()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sxbp_8h.html#adba112e91a18b8f807ce639167da1150">sxbp_result_t</a> sxbp_load_figure </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structsxbp__buffer__t.html">sxbp_buffer_t</a> *const&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsxbp__figure__t.html">sxbp_figure_t</a> *const&#160;</td>
          <td class="paramname"><em>figure</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempts to deserialise an SXBP figure from the given buffer. </p>
<p>A serialised SXBP figure is extracted from the buffer's data to the given figure, if the buffer data is valid, containing an SXBP figure in the data format this version of SXBP understands </p><dl class="section note"><dt>Note</dt><dd>The figure is overwritten in this process </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">buffer</td><td>The buffer to load the SXBP figure from </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">figure</td><td>The figure to store the deserialised SXBP figure in </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>SXBP_RESULT_OK</code> if the figure could be successfully deserialised </dd>
<dd>
<code>SXBP_RESULT_FAIL_MEMORY</code> if the figure could not be deserialised due to a memory error </dd>
<dd>
<code>SXBP_RESULT_FAIL_PRECONDITION</code> if the figure could not be deserialised because the buffer contains invalid data or data for a version of SXBP that this version cannot read </dd>
<dd>
<code>SXBP_RESULT_FAIL_PRECONDITION</code> if <code>buffer</code> or <code>figure</code> is <code>NULL</code> </dd></dl>
<dl class="section since"><dt>Since</dt><dd>v0.54.0 </dd></dl>

</div>
</div>
<a id="a5338e9ef3aafdc1d5aa13d0969e0d654"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5338e9ef3aafdc1d5aa13d0969e0d654">&#9670;&nbsp;</a></span>sxbp_render_figure_to_bitmap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sxbp_8h.html#adba112e91a18b8f807ce639167da1150">sxbp_result_t</a> sxbp_render_figure_to_bitmap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structsxbp__figure__t.html">sxbp_figure_t</a> *const&#160;</td>
          <td class="paramname"><em>figure</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsxbp__bitmap__t.html">sxbp_bitmap_t</a> *const&#160;</td>
          <td class="paramname"><em>bitmap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rasterises an image of the given figure to a basic bitmap object. </p>
<p>A 1-bit black/white bitmap image of the line formed by the SXBP figure is rendered to the given bitmap object </p><dl class="section note"><dt>Note</dt><dd>The bitmap is erased before the output is written to it </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">figure</td><td>The SXBP figure to render </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">bitmap</td><td>The bitmap to write the output to </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>SXBP_RESULT_OK</code> if the figure could be rendered successfully </dd>
<dd>
<code>SXBP_RESULT_FAIL_MEMORY</code> if the figure could not be rendered successfully </dd>
<dd>
<code>SXBP_RESULT_FAIL_PRECONDITION</code> if <code>figure</code> or <code>bitmap</code> is <code>NULL</code> </dd></dl>
<dl class="section since"><dt>Since</dt><dd>v0.54.0 </dd></dl>

</div>
</div>
<a id="ad7a36f65cec14ede4ba02eb7cee1bdb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7a36f65cec14ede4ba02eb7cee1bdb5">&#9670;&nbsp;</a></span>sxbp_render_figure()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sxbp_8h.html#adba112e91a18b8f807ce639167da1150">sxbp_result_t</a> sxbp_render_figure </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structsxbp__figure__t.html">sxbp_figure_t</a> *const&#160;</td>
          <td class="paramname"><em>figure</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsxbp__buffer__t.html">sxbp_buffer_t</a> *const&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sxbp_8h.html#a6190ffd788551f95618ccb01bf753723">sxbp_figure_renderer_t</a>&#160;</td>
          <td class="paramname"><em>render_callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsxbp__render__options__t.html">sxbp_render_options_t</a> *const&#160;</td>
          <td class="paramname"><em>render_options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>render_callback_options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Renders an image of the given figure, using the given render callback. </p>
<p>The render callback should write out the bytes of the rendered image to the given buffer. </p><dl class="section note"><dt>Note</dt><dd>The buffer is erased before the output is written to it </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">figure</td><td>The SXBP figure to render </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buffer</td><td>The buffer to write the image data out to </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">render_callback</td><td>A callback function which can render figures out to a specific image format, outputting the serialised image data to the given buffer </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">render_options</td><td>An optional pointer to options affecting the rendered output </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">render_callback_options</td><td>Optional type-agnostic pointer to additional options that are specific to this particular render callback.  No type-checking is done for <code>render_callback_options</code>, as the accepted type (if any) is entirely dependent on the render callback being used. Care must be taken to only pass a pointer to a type accepted by the used render callback. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>SXBP_RESULT_OK</code> if the figure could be rendered successfully </dd>
<dd>
<code>SXBP_RESULT_FAIL_PRECONDITION</code> if <code>figure</code>, <code>buffer</code> or <code>render_callback</code> are <code>NULL</code> </dd>
<dd>
Any other valid value for type <code>sxbp_result_t</code>, according to all the possible error codes that can be returned by the given render callback. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>v0.54.0 </dd></dl>

</div>
</div>
<a id="aa3fe98531a58171ad2c59cf18a92a9e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3fe98531a58171ad2c59cf18a92a9e5">&#9670;&nbsp;</a></span>sxbp_render_figure_to_null()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sxbp_8h.html#adba112e91a18b8f807ce639167da1150">sxbp_result_t</a> sxbp_render_figure_to_null </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structsxbp__figure__t.html">sxbp_figure_t</a> *const&#160;</td>
          <td class="paramname"><em>figure</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsxbp__buffer__t.html">sxbp_buffer_t</a> *const&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsxbp__render__options__t.html">sxbp_render_options_t</a> *const&#160;</td>
          <td class="paramname"><em>render_options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>render_callback_options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A dummy renderer function that does nothing. </p>
<p>This exists for testing purposes only  This function is currently unusable because it always returns the "not implemented" failure error code </p><dl class="section return"><dt>Returns</dt><dd><code>SXBP_RESULT_FAIL_UNIMPLEMENTED</code> </dd></dl>
<dl class="section since"><dt>Since</dt><dd>v0.54.0 </dd></dl>

</div>
</div>
<a id="aeab49c9531b7030e4e5809fa39d58685"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeab49c9531b7030e4e5809fa39d58685">&#9670;&nbsp;</a></span>sxbp_render_figure_to_pbm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sxbp_8h.html#adba112e91a18b8f807ce639167da1150">sxbp_result_t</a> sxbp_render_figure_to_pbm </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structsxbp__figure__t.html">sxbp_figure_t</a> *const&#160;</td>
          <td class="paramname"><em>figure</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsxbp__buffer__t.html">sxbp_buffer_t</a> *const&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsxbp__render__options__t.html">sxbp_render_options_t</a> *const&#160;</td>
          <td class="paramname"><em>render_options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>render_callback_options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Renders figures to PBM images. </p>
<p>If successful, the buffer will be filled with data which represents a binary format PBM image (P4 format). </p><dl class="section return"><dt>Returns</dt><dd><code>SXBP_RESULT_OK</code> if the figure could be rendered successfully </dd>
<dd>
<code>SXBP_RESULT_FAIL_PRECONDITION</code> if <code>figure</code> or <code>buffer</code> are <code>NULL</code> </dd>
<dd>
<code>SXBP_RESULT_FAIL_MEMORY</code> if a memory allocation error occurred </dd></dl>
<dl class="section since"><dt>Since</dt><dd>v0.54.0 </dd></dl>

</div>
</div>
<a id="affaa6bf0f878f3ffbcc5ae66ff4a1b17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affaa6bf0f878f3ffbcc5ae66ff4a1b17">&#9670;&nbsp;</a></span>sxbp_render_figure_to_svg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sxbp_8h.html#adba112e91a18b8f807ce639167da1150">sxbp_result_t</a> sxbp_render_figure_to_svg </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structsxbp__figure__t.html">sxbp_figure_t</a> *const&#160;</td>
          <td class="paramname"><em>figure</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsxbp__buffer__t.html">sxbp_buffer_t</a> *const&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsxbp__render__options__t.html">sxbp_render_options_t</a> *const&#160;</td>
          <td class="paramname"><em>render_options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>render_callback_options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Renders figures to SVG images. </p>
<p>If successful, the buffer will be filled with data which represents an SVG image. </p><dl class="section return"><dt>Returns</dt><dd><code>SXBP_RESULT_OK</code> if the figure could be rendered successfully </dd>
<dd>
<code>SXBP_RESULT_FAIL_PRECONDITION</code> if <code>figure</code> or <code>buffer</code> are <code>NULL</code> </dd>
<dd>
<code>SXBP_RESULT_FAIL_MEMORY</code> if a memory allocation error occurred </dd></dl>
<dl class="section since"><dt>Since</dt><dd>v0.54.0 </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a65c0388820516f27d300efabab54ae10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65c0388820516f27d300efabab54ae10">&#9670;&nbsp;</a></span>SXBP_VERSION</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structsxbp__version__t.html">sxbp_version_t</a> SXBP_VERSION</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stores the current version of sxbp. </p>
<dl class="section since"><dt>Since</dt><dd>v0.27.0 </dd></dl>

</div>
</div>
<a id="ac7627a48c48e06fa278e53bdc91376cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7627a48c48e06fa278e53bdc91376cf">&#9670;&nbsp;</a></span>SXBP_BEGIN_BUFFER_MAX_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const size_t SXBP_BEGIN_BUFFER_MAX_SIZE</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The maximum size of buffer that can be used to begin a figure. </p>
<p>This ensures that a figure will not produce a line which will exceed the maximum bounds of the grid in which it is plotted. It is derived like so: <code>(((2^32 - 1) × 2) - 1) ÷ 8 = 1073741823.625</code> and this is due to 32-bit bounds being used for the figure's grid. This means no file that is 1GiB in size or larger can be used to create a figure, but less than 1GiB is fine. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_c99b4bd6479b6378cc5576b72b3ab7c8.html">sxbp</a></li><li class="navelem"><a class="el" href="sxbp_8h.html">sxbp.h</a></li>
    <li class="footer">Generated on Mon Dec 17 2018 03:56:08 for sxbp by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.14 </li>
  </ul>
</div>
</body>
</html>
